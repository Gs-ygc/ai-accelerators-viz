<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hardware Performance vs. Power</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Plotly.js CDN for interactive plotting -->
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <!-- D3.js for CSV parsing (includes d3-dsv functionality) -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* Custom styles for better aesthetics and responsiveness */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light gray background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }
        #plot-container {
            background-color: #ffffff;
            border-radius: 1rem; /* Rounded corners */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* Subtle shadow */
            padding: 1.5rem;
            width: 100%;
            max-width: 2000px; /* Max width for larger screens */
            box-sizing: border-box;
        }
        #loading-message {
            text-align: center;
            padding: 2rem;
            font-size: 1.25rem;
            color: #4a5568;
        }
        /* Ensure plotly div takes available space */
        #plot {
            width: 100%;
            height: 1100px; /* Fixed height for the plot */
        }
    </style>
</head>
<body>
    <div id="plot-container">
        <h1 class="text-2xl md:text-3xl font-bold text-center text-gray-800 mb-6">
            Peak Performance vs. Power of Hardware for AI <a id="repo_link"> </a>
        </h1>
        <div id="loading-message" class="text-gray-600">Loading data and generating plot...</div>
        <div id="plot" class="hidden"></div> <!-- Plotly plot will be rendered here -->
    </div>

    <script>
        // Define the GitHub repository details and file paths
        // Extract GitHub repo info from github.io URL if present, otherwise use defaults
        let GITHUB_REPO_OWNER = 'mandulaj';
        let GITHUB_REPO_NAME = 'ai-accelerators-viz';
        const GITHUB_BRANCH = 'main';

        // If hosted on github.io, try to extract owner/repo from the URL
        const githubIoMatch = window.location.hostname.match(/^([^.]+)\.github\.io$/);
        if (githubIoMatch) {
            GITHUB_REPO_OWNER = githubIoMatch[1];
            // Try to extract repo name from pathname (e.g. /repo-name/)
            const repoMatch = window.location.pathname.match(/^\/([^\/]+)\//);
            if (repoMatch) {
            GITHUB_REPO_NAME = repoMatch[1];
            }
        }

        //

        const fileNames = [
            'peak_accelerators_ieee_hpec_2019.csv',
            'peak_accelerators_ieee_hpec_2020.csv',
            'peak_accelerators_ieee_hpec_2021.csv',
            'peak_accelerators_ieee_hpec_2022.csv',
            'peak_accelerators_ieee_hpec_2023.csv'
        ];

        // Construct raw GitHub URLs for each file
        const filePaths = fileNames.map(name =>
            `https://raw.githubusercontent.com/${GITHUB_REPO_OWNER}/${GITHUB_REPO_NAME}/${GITHUB_BRANCH}/${name}`
        );

        // Generrate the repository link
        const repoUrl = `https://github.com/${GITHUB_REPO_OWNER}/${GITHUB_REPO_NAME}`;
        const repoLinkText = `View the repository on GitHub`;
        const repoLink = document.getElementById('repo_link');
        repoLink.innerHTML = `- <a href="${repoUrl}" class="text-blue-600 hover:underline" target="_blank">${repoLinkText}</a>`;

        // Function to categorize technologies
        function categorizeTechnology(tech) {
            if (tech === null || tech === undefined || String(tech).trim() === '') {
                return null; // Return null for missing or empty values
            }
            const lowerTech = String(tech).toLowerCase();
            if (lowerTech.includes('cpu') || lowerTech.includes('multicore') || lowerTech.includes('manycore')) {
                return 'CPU';
            } else if (lowerTech.includes('gpu')) {
                return 'GPU';
            } else if (lowerTech.includes('dataflow')) {
                return 'dataflow';
            } else {
                return 'Others';
            }
        }

        // Function to categorize precision
        function categorizePrecision(prec) {
            if (prec === null || prec === undefined || String(prec).trim() === '') {
                return 'Other';
            }
            const lowerPrec = String(prec).toLowerCase();
            if (lowerPrec.includes('fp32')) return 'FP32';
            if (lowerPrec.includes('fp16')) return 'FP16';
            if (lowerPrec.includes('int8')) return 'INT8';
            if (lowerPrec.includes('bf16')) return 'BF16';
            if (lowerPrec.includes('tf32')) return 'TF32';
            if (lowerPrec.includes('mixed')) return 'Mixed';
            return 'Other';
        }

        // Define precision symbols mapping
        const precisionSymbols = {
            'FP32': 'circle',
            'FP16': 'square',
            'INT8': 'diamond',
            'BF16': 'cross',
            'TF32': 'triangle-up',
            'Mixed': 'x',
            'Other': 'star'
        };

        // Function to fetch and process all CSV files
        async function loadAndProcessData() {
            try {
                const allData = [];
                for (const path of filePaths) {
                    const response = await fetch(path);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status} for ${path}`);
                    }
                    const csvText = await response.text();
                    const parsedData = d3.csvParse(csvText);
                    allData.push(...parsedData);
                }

                // Process the concatenated data
                const processedData = allData.map(row => {
                    // Ensure 'Power' and 'PeakPerformance' are numbers
                    const power = parseFloat(row.Power);
                    const peakPerformance = parseFloat(row.PeakPerformance);

                    return {
                        ...row,
                        Power: isNaN(power) ? null : power,
                        PeakPerformance: isNaN(peakPerformance) ? null : peakPerformance,
                        TechnologyCategory: categorizeTechnology(row.Technology),
                        PrecisionCategory: categorizePrecision(row.Precision) // Add categorized precision
                    };
                }).filter(row =>
                    row.PeakPerformance !== null && row.Power !== null && row.PeakPerformance > 1000
                );

                return processedData;

            } catch (error) {
                console.error("Error loading or processing data:", error);
                document.getElementById('loading-message').innerText = 'Failed to load data. Please check console for details.';
                return []; // Return empty array on error
            }
        }

        // Function to create and render the Plotly chart
        async function createPlot() {
            const loadingMessage = document.getElementById('loading-message');
            const plotDiv = document.getElementById('plot');

            const dataFiltered = await loadAndProcessData();

            if (dataFiltered.length === 0) {
                loadingMessage.innerText = 'No data available to plot after filtering.';
                return;
            }

            // Calculate min/max for axes based on data points
            const allPowers = dataFiltered.map(d => d.Power).filter(p => p !== null);
            const allPerformances = dataFiltered.map(d => d.PeakPerformance).filter(p => p !== null);

            const minPower = Math.min(...allPowers);
            const maxPower = Math.max(...allPowers);
            const minPerformance = Math.min(...allPerformances);
            const maxPerformance = Math.max(...allPerformances);

            // Define a small padding for log scale axes
            const logPadding = 0.1; // 10% padding on each side in log space

            const xMin = Math.log10(minPower) - logPadding;
            const xMax = Math.log10(maxPower) + logPadding;
            const yMin = Math.log10(minPerformance) - logPadding;
            const yMax = Math.log10(maxPerformance) + logPadding;


            // Define colors for categories
            const categoryColors = {
                'CPU': 'rgb(66, 135, 245)',    // Blue
                'GPU': 'rgb(52, 199, 89)',    // Green
                'dataflow': 'rgb(255, 140, 0)', // Orange
                'Others': 'rgb(220, 53, 69)'   // Red
            };

            const plotTraces = [];

            // Get unique categories and precisions
            const uniqueTechnologyCategories = [...new Set(dataFiltered.map(d => d.TechnologyCategory))].filter(Boolean).sort();
            const uniquePrecisions = [...new Set(dataFiltered.map(d => d.PrecisionCategory))].filter(Boolean).sort((a, b) => {
                // Custom sort for precisions for consistent legend order
                const order = ['FP32', 'FP16', 'BF16', 'INT8', 'TF32', 'Mixed', 'Other'];
                return order.indexOf(a) - order.indexOf(b);
            });

            // Create a trace for each combination of TechnologyCategory and Precision
            for (const category of uniqueTechnologyCategories) {
                for (const precision of uniquePrecisions) {
                    const subset = dataFiltered.filter(d =>
                        d.TechnologyCategory === category && d.PrecisionCategory === precision
                    );

                    if (subset.length > 0) {
                        plotTraces.push({
                            x: subset.map(d => d.Power),
                            y: subset.map(d => d.PeakPerformance),
                            mode: 'markers',
                            type: 'scatter',
                            name: `${category} - ${precision}`, // Combined name for legend
                            marker: {
                                size: 10,
                                color: categoryColors[category], // Color by TechnologyCategory
                                symbol: precisionSymbols[precision] || 'circle', // Shape by Precision, default to circle
                                line: {
                                    color: 'rgba(0, 0, 0, 0.5)',
                                    width: 1
                                }
                            },
                            // Custom hover text to show product name, company, and precision
                            text: subset.map(d => {
                                const info = {};
                                if (d.Product) info.Product = d.Product;
                                if (d.Company) info.Company = d.Company;
                                if (d.PeakPerformance) info.PeakPerformance = d.PeakPerformance;
                                if (d.Precision) info.Precision = d.Precision;
                                if (d.Power) info.Power = d.Power;
                                if (d.Technology) info.Technology = d.Technology;
                                if (d.IorT) info.IorT = d.IorT;
                                if (d.FormFactor) info.FormFactor = d.FormFactor;
                                if (d.PlotLocation) info.PlotLocation = d.PlotLocation;
                                if (d.Hide) info.Hide = d.Hide;
                                if (d.Updated) info.Updated = d.Updated;
                                if (d.Notes && d.Notes.trim() !== '') info.Notes = d.Notes;
                                if (d.ReferenceURL) info.ReferenceURL = d.ReferenceURL;
                                if (d.Reference) info.Reference = d.Reference;
                                info.Notes = (d.Notes && d.Notes.trim() !== '') ? `<b>Notes:</b> ${d.Notes}` : '';
                                // Format PeakPerformance to readable units, including larger scales
                                if (d.PeakPerformance) {
                                    const val = Number(d.PeakPerformance);
                                    if (val >= 1e18) {
                                        info.PeakPerformanceReadable = (val / 1e18).toFixed(2) + ' EOP/s'; // Exa
                                    } else if (val >= 1e15) {
                                        info.PeakPerformanceReadable = (val / 1e15).toFixed(2) + ' POP/s'; // Peta
                                    } else if (val >= 1e12) {
                                        info.PeakPerformanceReadable = (val / 1e12).toFixed(2) + ' TOP/s'; // Tera
                                    } else if (val >= 1e9) {
                                        info.PeakPerformanceReadable = (val / 1e9).toFixed(2) + ' GOP/s'; // Giga
                                    } else if (val >= 1e6) {
                                        info.PeakPerformanceReadable = (val / 1e6).toFixed(2) + ' MOP/s'; // Mega
                                    } else if (val >= 1e3) {
                                        info.PeakPerformanceReadable = (val / 1e3).toFixed(2) + ' KOP/s'; // Kilo
                                    } else {
                                        info.PeakPerformanceReadable = val + ' OP/s';
                                    }
                                }
                                return info;
                            }),
                            hoverinfo: 'text',
                            hovertemplate:
                                [
                                    '<b>Product:</b> %{text.Product}',
                                    '<b>Company:</b> %{text.Company}',
                                    '<b>Peak Performance:</b> %{text.PeakPerformanceReadable}',
                                    '<b>Precision:</b> %{text.Precision}',
                                    '<b>Power:</b> %{text.Power} W',
                                    '%{text.Notes}',
                                    '<a href="%{text.ReferenceURL}" target="_blank">Reference</a>'
                                ]
                                .filter(line => line !== '')
                                .join('<br>') +
                                '<extra></extra>'
                        });
                    }
                }
            }

            // Add diagonal lines for Ops/W ratio
            const opsPerWattRatios = [1e9,1e10,1e11, 1e12, 1e13, 1e14]; // 1 TOP/W, 10 TOP/W, 100 TOP/W, etc.

            // Helper function to format ratio labels
            function formatRatioLabel(ratio) {
                if (ratio >= 1e12) {
                    return `${ratio / 1e12} TOP/W`;
                } else if (ratio >= 1e9) {
                    return `${ratio / 1e9} GOP/W`; // GigaOps/W
                }
                return `${ratio} Ops/W`;
            }

            opsPerWattRatios.forEach(ratio => {
                const lineX = [];
                for (let p = Math.pow(10, xMin); p <= Math.pow(10, xMax); p *= 1.1) {
                    lineX.push(p);
                }
                lineX.push(Math.pow(10, xMax));

                const lineY = lineX.map(power => power * ratio);

                const filteredLineX = [];
                const filteredLineY = [];
                for (let i = 0; i < lineX.length; i++) {
                    if (lineY[i] >= Math.pow(10, yMin) && lineY[i] <= Math.pow(10, yMax)) {
                        filteredLineX.push(lineX[i]);
                        filteredLineY.push(lineY[i]);
                    }
                }

                if (filteredLineX.length > 1) {
                    plotTraces.push({
                        x: filteredLineX,
                        y: filteredLineY,
                        mode: 'lines',
                        type: 'scatter',
                        name: formatRatioLabel(ratio),
                        line: {
                            color: 'rgba(128, 128, 128, 0.5)',
                            dash: 'dash',
                            width: 1
                        },
                        hoverinfo: 'skip',
                        showlegend: false
                    });
                }
            });


            const layout = {
                xaxis: {
                    title: {
                        text: 'Peak Power (W)',
                        font: { size: 14 }
                    },
                    type: 'log',
                    range: [xMin, xMax],
                    gridcolor: '#e2e8f0',
                    linecolor: '#cbd5e1',
                    linewidth: 1
                },
                yaxis: {
                    title: {
                        text: 'Peak Performance (Op/s)',
                        font: { size: 14 }
                    },
                    type: 'log',
                    range: [yMin, yMax],
                    gridcolor: '#e2e8f0',
                    linecolor: '#cbd5e1',
                    linewidth: 1
                },
                title: {
                    text: 'Peak Performance vs. Power of Hardware for AI by CPU, GPU, and Others',
                    font: { size: 18, color: '#333' },
                    x: 0.5,
                    xanchor: 'center'
                },
                hovermode: 'closest',
                legend: {
                    orientation: 'h', // Horizontal legend
                    yanchor: 'bottom',
                    y: 1.02,
                    xanchor: 'right',
                    x: 1,
                    bgcolor: 'rgba(255, 255, 255, 0.8)',
                    bordercolor: '#ccc',
                    borderwidth: 1,
                    font: { size: 10 } // Slightly smaller font for potentially more entries
                },
                margin: {
                    l: 80,
                    r: 50,
                    b: 80,
                    t: 100,
                    pad: 4
                },
                paper_bgcolor: '#ffffff',
                plot_bgcolor: '#ffffff',
                font: {
                    family: 'Inter, sans-serif',
                    color: '#333'
                },
                autosize: true
            };

            loadingMessage.classList.add('hidden');
            plotDiv.classList.remove('hidden');

            Plotly.newPlot('plot', plotTraces, layout, {
                responsive: true,
                displayModeBar: true,
                modeBarButtonsToRemove: ['lasso2d', 'select2d']
            });

            // Add click event listener to the plot
            plotDiv.on('plotly_click', function(data) {
                if (data.points.length > 0) {
                    const point = data.points[0];
                    const referenceURL = point.text.ReferenceURL; // Access the ReferenceURL from the custom text object

                    if (referenceURL && referenceURL.startsWith('http')) { // Ensure it's a valid URL
                        window.open(referenceURL, '_blank'); // Open in a new tab
                    } else {
                        console.warn("No valid ReferenceURL found for the clicked point:", point);
                    }
                }
            });
        }

        window.onload = createPlot;
    </script>
</body>
</html>
